# -*- coding: utf-8 -*-
"""проект сегментация rfm

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/10mVyimk2hAPVRMKNT9qiGS4kIshbBinD
"""

from google.colab import files
import pandas as pd
uploaded_5 = files.upload()

df = pd.read_csv(next(iter(uploaded_5)), sep=',')
display(df.head(5))

display(df.info())

df['Date'] = pd.to_datetime(df['Date'])

display(df)

display(df.info())

display(len(df['Gender'].unique()))
display(len(df['Product Category'].unique()))
display(df['Gender'].unique())
display(df['Product Category'].unique())

import matplotlib.pyplot as plt

plt.hist(df['Total Amount'])
plt.title('Распределение цены')
plt.xlabel('цена за шт')
plt.ylabel('количество шт')
plt.show()

plt.boxplot(df['Age'])
plt.title('распеделение возраста')
plt.show()

plt.hist(df['Price per Unit'])
plt.title('распеделение цены за штуку')
plt.xlabel('цена за шт')
plt.ylabel('количество шт')
plt.show()

min_age = min(df['Age'])
print(min_age)
max_age = max(df['Age'])
print(max_age)

print(df.isna().sum())

#дубликатов нет
print(df.duplicated().sum())

#day_name - имя дня недели пятница/понедельник и тд, day_of_week - числовой индекс дня 0 - понедельник
df['year'] = df['Date'].dt.year
df['mouth'] = df['Date'].dt.month
display(df)

df['day'] = df['Date'].dt.day_of_week
display(df)

# df.groupby(df['mouth'] - группируем именно этот столбец [Total Amount] - по какому столбцу группируем)
grouped_month = df.groupby('mouth').agg(revenue_month = ('Total Amount', 'sum'))
display(grouped_month.plot())
plt.title('выручка по месяцам')
plt.xlabel('месяц')
plt.ylabel('сумма выручки')

# 0 - понедельник и тогда они по умолчанию ставятся в порядке с 0 до 6.
grouped_day= df.groupby('day').agg(revenue_day = ('Total Amount', 'sum'))
display(grouped_day.plot())
plt.title('выручка по дням недели')
plt.xlabel('месяц')
plt.ylabel('сумма выручки')

def age_category(Age):
  if Age < 30:
   return 'young'
  elif 30 <= Age <= 50:
   return 'middle age'
  elif Age > 50:
   return 'old'
# теперь присоединяю функцию прописнную в def к изначальному столбцу возраста и называю новый столбец df['category_age']
#.apply('category_age') - ссылаюсь на категорию возраста, к столбцу age_category примени функцию apply
df['category_age'] = df['Age'].apply(age_category)
display(df)

from ast import In
#def season(month):
#if month == [12,1,2]: - тут такая же должна быть такой же параметр как и в season(month)
def season(month):
  if month in [12,1,2]:
   return 'winter'
  elif month in [3,4,5]:
    return 'spring'
  elif month in [6,7,8]:
    return 'summer'
  elif month in [9,10,11]:
    return 'autumn'
df['season'] = df['mouth'].apply(season)
display(df)

#дальше буду делать сводную таблицу по по возрастам клиентов и полу для сравнения групп
pivot_1 = pd.pivot_table(df,index = 'category_age',
                         values = 'Total Amount',
                         columns = 'Gender',
                         aggfunc = 'sum')
display(pivot_1)
#из сводной таблицы видно что группы приносят схожую выручку, хотя люди среднего возраста покупают больше.

pivot_2 = pd.pivot_table(df, index = 'season',
                         values = 'Total Amount',
                         columns = 'mouth',
                         aggfunc = 'sum',
                         margins = True,
                         margins_name = 'Всего')


display(pivot_2)
#видно, что на категорию Clothing есть всплеск спроса весной, а зимой всплеск на Electronics

pivot_3 = pd.pivot_table(df, index = 'mouth',
                         values = 'Total Amount',
                         columns = 'Product Category',
                         aggfunc = 'sum',
                         margins = True,
                         margins_name = 'Всего')


display(pivot_3)
# декабрь и февраль, май, октябрь принесли выручку выше среднего

pivot_4 = pd.pivot_table(df, index = ['category_age','Gender'],
                         values = 'Total Amount',
                         columns = 'Product Category',
                         aggfunc = 'sum',
                         margins = True,
                         margins_name = 'Всего')


display(pivot_4)

import scipy.stats as stats
import statsmodels.stats.api as sms
import numpy as np
from scipy.stats import shapiro

#гипотеза H0: спрос на товары разных категорий не различается в зависимости от времени года
#гипотеза H1: спрос на товары разных категорий различается в зависимости от времени года

#проверим нормальность распределения данных: H0 - данные распределены нормально H1 - данные не распределенные нормально
category_1 = pivot_3['Beauty'][0:12]
category_2 = pivot_3['Clothing'][0:12]
category_3 = pivot_3['Electronics'][0:12]

print(shapiro(category_1))
print(shapiro(category_2))
print(shapiro(category_3))
#так как p значение сильно < 0,05, то  отвергаем нулевую гипотезу о нормальности распределения

display(df)

display(df['order_recency'])

#rfm анализ по каждому клиенту отдельно.
import pandas as pd

# 1 рассчитать кол-во дней от анализа до последней покупки.
df['order_recency'] = pd.to_datetime('2024-01-01') - pd.to_datetime(df['Date'].dt.date)

# 2 Необходимо сгруппировать данные для каждого пользователя и данные для RFM анализа.

rfm = df.groupby('Customer ID').agg(
    recency = ('order_recency', lambda x: x.min().days),
    frequeny = ('Transaction ID', 'nunique'),
    monetary_value = ('Total Amount', 'sum')
).reset_index()

# 3 определить параметр разбивки по группам по каждому признаку.

# Создание RFM сегментов
rfm['r'] = pd.qcut(rfm['recency'], q=3, labels=[3, 2, 1])
rfm['f'] = pd.cut(rfm['frequeny'], [0, 2, 10, 1000], labels=[1, 2, 3])
rfm['m'] = pd.qcut(rfm['monetary_value'], q=3, labels=[1, 2, 3])

display(rfm)


# 4 определение rfm иднекса сегмента

rfm[['r','f','m']] = rfm[['r','f','m']].astype('str')
rfm['rfm_group'] = rfm['r'] + rfm['f'] + rfm['m']

rfm[['r','f','m']] = rfm[['r','f','m']].astype('int')
rfm['rfm_sum'] = rfm[['r','f','m']].sum(axis =1)

# 5 Необходимо сгруппировать данные по сегментам и посчитать их размер

rfm_group = rfm.groupby('rfm_group').agg(
    {
        'Customer ID' : 'nunique',
        'rfm_sum' : 'mean'
    }
).reset_index()

display(rfm_group.sort_values(by = 'Customer ID'))

import plotly.express as px
fig = px.treemap(rfm_group,
                 path= ['rfm_group'],
                 values = 'Customer ID',
                 color= 'rfm_sum',
                 color_continuous_scale= 'Sunset',
                 title = 'RFM сегментация пользователей')
fig.show()

#после анализа принято решение поменять параметр frequeny, с каждого клиента отдельно на количество товаров купленных каждым кллиентом

# rfm анализ, расчет количества дней с последней покупки
#возвращает массив дат без времени из столбца объектов, в нашем случае был datetime, стал объект, то есть массив
df['order_recency'] = pd.to_datetime('2025-11-15') - df['Date']

# расчитать frequeny, Monetary, делаем через присвоение переменных для дальнейщего анализа
# вид: df.groupby('столбец_группировки').agg({'столбец': 'функция'})
rfm = df.groupby('Customer ID').agg(
    recency = ('order_recency', lambda x: x.min().days),
    frequeny = ('Quantity', 'unique'),
    monetary = ('Total Amount', 'sum')
).reset_index()

# присвоить парамерты по сегментам клиентов от 1 до 3
#функция из библиотеки Pandas, которая используется для разделения непрерывных числовых данных
#на дискретные интервалы или "корзины" (bins).
# в cut можно явно указать границы интервалов
rfm['r'] = pd.qcut(rfm['recency'], q = 3, labels = [3, 2, 1])
rfm['f'] = pd.cut(rfm['frequeny'], [0, 2, 3, 4], labels = [1, 2, 3])
rfm['m'] = pd.qcut(rfm['monetary'], q = 3, labels=[1, 2, 3])

display(rfm)
# определение индекса сегмента
# astype это метод для явного изменения типа данных объектов Pandas (например, Series или DataFrame
rfm[['r','f','m']] = rfm[['r','f','m']].astype('str')
rfm['rfm_group'] = rfm['r'] + rfm['f'] + rfm['m']

rfm[['r','f','m']] = rfm[['r','f','m']].astype('int')
rfm['rfm_sum'] = rfm[['r','f','m']].sum(axis =1)

#группируем данные по сгментам и считаем их размер
rfm_group = rfm.groupby('rfm_group').agg({
    'Customer ID' : 'nunique',
        'rfm_sum' : 'mean'
} ).reset_index()

display(rfm_group.sort_values(by = 'Customer ID'))

#рисую график сегментации
import plotly.express as px

fig = px.treemap(rfm_group,
                 path = ['rfm_group'],
                 values = 'Customer ID',
                 color = 'rfm_sum',
                 color_continuous_scale= 'Sunset',
                 title = 'RFM сегментация пользователей')

fig.show()

display(df['Quantity'].unique())

"""клиентов сегмента 111 много, для привлечения их к покупкам можно предложить особые скидки.
также большая доля клиентов сегмента 311, это те кто недавно совершил покупку, а значит этих клиентов можно вовлечь в наш бренд.
клиентов сегмента 333, которые покупали в больших количестах и недавно немного, им можно предложить высокие уровни в программе лояльности или эксклюзивный доступ.
"""